import{_ as o,o as a,c as n,a as s,b as l,t,d as c}from"./app.4ad49d17.js";const h=JSON.parse('{"title":"什么是 Vite ?","description":"","frontmatter":{"title":"什么是 Vite ?"},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"pnpm create vite 做了什么？","slug":"pnpm-create-vite-做了什么","link":"#pnpm-create-vite-做了什么","children":[]},{"level":2,"title":"vite 的预加载","slug":"vite-的预加载","link":"#vite-的预加载","children":[{"level":3,"title":"vite的依赖于构建","slug":"vite的依赖于构建","link":"#vite的依赖于构建","children":[]}]}],"relativePath":"ViteDetailed/pages/01什么是vite.md","lastUpdated":1679189067000}'),p={name:"ViteDetailed/pages/01什么是vite.md"},i={id:"frontmatter-title",tabindex:"-1"},d=s("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),r=c(`<p><a href="https://www.bilibili.com/video/BV1GN4y1M7P5" target="_blank" rel="noreferrer">参考学习网课地址--b站付金权的前端课</a></p><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-hidden="true">#</a></h2><p>如果我们要学习<code>vite</code>，那么我们要先了解什么是<code>vite</code>，有人说:<code>vite</code>就是<code>webpack</code>，一样的嘛！<br> 对的 其实个人认为这两个差不多，但是现在为什么<code>Vue</code>团队逐渐抛弃掉<code>webpack</code>，转而使用<code>vite</code>了呢?我个人认为</p><ol><li><code>vite</code>快，是真的要比<code>webpack</code>快，具体体现在了打包、开发环境的热更新、项目启动上</li><li>相比于<code>vite</code>，<code>webpack</code>配置和使用起来是过于麻烦的(不排除多年以后 <code>vite</code> 也变成这样)，例如使用scss，不知道多少开发者被<code>node-sass</code>，<code>sass-loader</code>这两个东西折磨过</li><li>个人认为，可能也有尤雨溪的一些私心在里面吧，想要完善整个<code>Vue</code>生态，以至于后来的开发者会认为，<code>vite</code>天生就是和<code>Vue</code>绑定再一起的，其实<code>vite</code>是可以抽出来单独用的</li></ol><h2 id="pnpm-create-vite-做了什么" tabindex="-1">pnpm create vite 做了什么？ <a class="header-anchor" href="#pnpm-create-vite-做了什么" aria-hidden="true">#</a></h2><p>当我们敲下 <code>pnpm create vite</code> 后</p><ol><li>全局安装<code>create vite</code>脚手架</li><li>再运行<code>create-vite</code>的<code>bin</code>目录下的一个执行配置开始构建项目</li></ol><p>这其实和我们<code>Vue2</code>的<code>vue-cli</code>是类似的，我们先去安装<code>vue-cli</code>然后再去使用cli创建项目<br> 这里其实部分人会有个误区，认为这是<code>vite</code>再帮我们去创建项目，其实不然 <strong>这个过程中vite什么都没做</strong></p><ul><li><code>vue-cli</code>:给你一套初始化后的模板，<strong>内置webpack</strong></li><li><code>create-vite</code>:给你一套所有东西都准备好的模板，<strong>内置vite</strong></li></ul><p><code>vue</code>团队希望弱化<code>vite</code>的存在，希望更多的去使用 <code>create-vite</code> ，但是我们去学习的时候这两个是要分清楚的。<br><code>vite</code>和<code>webpack</code>都是开箱即用的(out of box)</p><p><strong>例如:</strong> 你自己去构建一个项目，想要使用<code>vite</code>，那么当我们<code>pnpm init</code>后，手动创建<code>index.html</code>然后下载<code>vite</code>在<code>package.json</code>中的<code>scripts</code>对象中添加<code>&quot;dev&quot;:&quot;vite&quot;</code>，然后就可以直接<code>pnpm dev</code>去使用<code>vite</code>帮你启动项目了</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">scripts</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">: </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">       </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">dev</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">vite</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">       </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">build</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">vite build</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">,</span></span>
<span class="line"></span></code></pre></div><h2 id="vite-的预加载" tabindex="-1">vite 的预加载 <a class="header-anchor" href="#vite-的预加载" aria-hidden="true">#</a></h2><p>在学习vite的预加载之前，我们要先了解一些东西，我们平时导包，一般分为两种情况</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> xxx </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">包名</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 直接从 node_modules 里导入</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> xxx </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./xxx/xxx/xxx.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 从文件中导入</span></span>
<span class="line"></span></code></pre></div><p>如果我们不使用<code>vite</code>，那么在<code>index.html</code>中使用<code>script</code>标签<code>type=&quot;module&quot;</code>开启<code>ES6</code>的话 从文件中导入也是可以实现的，但是我们无法直接通过包名导入包<br> 既然我们已经规范使用<code>node_modules</code>来导包，为什么浏览器不直接帮我们导入呢？ 这涉及到一个包的嵌套的问题，如果浏览器可以通过<code>node_modules</code>来导包，那么可能某些包依赖更多包，会一直嵌套进去无穷无尽，那么我们会有无数个网络请求资源。</p><h3 id="vite的依赖于构建" tabindex="-1">vite的依赖于构建 <a class="header-anchor" href="#vite的依赖于构建" aria-hidden="true">#</a></h3><p>那么如果我们使用<code>vite</code>，他是怎么帮我们处理的呢？ 当我们通过<code>vite</code>启动后，他看到有直接导入包，且没有相对路径的时候，会开启路径补全，这个是在构建周期中做的事情，然后启动本地服务器，运行<code>index.html</code>，这和你使用<code>LiveSeaver</code>是类似的不过后者不带预构建功能<br> 找寻过程是从当前目录一级一级的向上找，直至找到根目录或者找到对应依赖后停止</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> _ </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">loadsh</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> _ </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/node_modules/.vite/deps/lodash.js?v=*</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span></code></pre></div><p><strong>为什么补全的路径都是绝对路径而不是相对路径呢？</strong><br> 因为我们要区分生产环境和开发环境，当我们处于开发环境时 每次<code>pnpm dev</code>都会从新跑一遍项目，那么我们使用相对路径也会从新找一遍，但如果我们是生产环境的话，<code>vite</code>会交给<code>rollup</code>的库去完成生产环境的打包。<br> 还有一个原因就是，我们有些库用的是<code>commonJS规范</code>导出和编写，有些是使用<code>ESmodule规范</code>导出和编写，那么无法做到统一，所以<code>vite</code>会在启动的时候，找到所有的依赖，先使用<code>ESbuild</code>将所有模块统一成<code>ESmodule规范</code>，然后将所有需要的模块打包至<code>node_modules/.vite/deps目录</code>下，这样就可以对所有模块进行一个统一集成，并且同时也解决了缓存的问题，如果某个模块有更新，那么直接删除掉从新打包新的模块，这样未更新的模块使用静态缓存文件，已更新的则从新打包，大大减少了打包速度和启动速度，不至于某个模块更新导致整体全部更新的情况。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// a.js</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">a</span><span style="color:#89DDFF;">(){}</span></span>
<span class="line"></span></code></pre></div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//index.js</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./a.js</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 这个写法相当于 </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./a.js</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> a</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>vite重写后</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//index.js?v=*</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">a</span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span></code></pre></div><p>它解决了三个问题</p><ol><li>不同的第三方包会有不同的导出格式，这个是<code>vite</code>无法约束的问题</li><li>一次性对路径的处理上可以直接使用<code>.vite/deps</code>，方便路径重写</li><li>网络多包传输的性能问题，假设一个库依赖了很多的模块，那么会造成性能问题，这也是原生<code>esmodule</code>规范不敢支持<code>node_modules</code>的原因之一 有了依赖于构建以后 ,无论他又多少<code>export</code>和<code>import</code>，<code>vite</code>会尽量的去将其继承成一个或者几个模块</li></ol>`,26);function D(e,y,F,C,A,v){return a(),n("div",null,[s("h1",i,[l(t(e.$frontmatter.title)+" ",1),d]),r])}const m=o(p,[["render",D]]);export{h as __pageData,m as default};
